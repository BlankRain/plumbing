<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>plumbing.fnk.schema documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Plumbing 0.4.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plumbing</span></div></div></li><li class="depth-2 branch"><a href="plumbing.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fnk</span></div></div></li><li class="depth-3 branch"><a href="plumbing.fnk.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-3 branch"><a href="plumbing.fnk.pfnk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfnk</span></div></a></li><li class="depth-3 current"><a href="plumbing.fnk.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch"><a href="plumbing.graph.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2"><a href="plumbing.graph-async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph-async</span></div></a></li><li class="depth-3"><a href="plumbing.graph.positional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>positional</span></div></a></li><li class="depth-2"><a href="plumbing.map.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>map</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="plumbing.fnk.schema.html#var-assert-distinct"><div class="inner"><span>assert-distinct</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-assert-iae"><div class="inner"><span>assert-iae</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-assert-satisfies-schema"><div class="inner"><span>assert-satisfies-schema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-compose-schemata"><div class="inner"><span>compose-schemata</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-explicit-schema-key-map"><div class="inner"><span>explicit-schema-key-map</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-GraphInputSchema"><div class="inner"><span>GraphInputSchema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-GraphIOSchemata"><div class="inner"><span>GraphIOSchemata</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-guess-expr-output-schema"><div class="inner"><span>guess-expr-output-schema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-InputSchema"><div class="inner"><span>InputSchema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-IOSchemata"><div class="inner"><span>IOSchemata</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-map-schema.3F"><div class="inner"><span>map-schema?</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-MapOutputSchema"><div class="inner"><span>MapOutputSchema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-non-map-diff"><div class="inner"><span>non-map-diff</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-non-map-union"><div class="inner"><span>non-map-union</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-OutputSchema"><div class="inner"><span>OutputSchema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-possibly-contains.3F"><div class="inner"><span>possibly-contains?</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-required-toplevel-keys"><div class="inner"><span>required-toplevel-keys</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-safe-get"><div class="inner"><span>safe-get</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-Schema"><div class="inner"><span>Schema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-schema-diff"><div class="inner"><span>schema-diff</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-schema-key"><div class="inner"><span>schema-key</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-sequence-schemata"><div class="inner"><span>sequence-schemata</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-split-schema"><div class="inner"><span>split-schema</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-split-schema-keys"><div class="inner"><span>split-schema-keys</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-union-input-schemata"><div class="inner"><span>union-input-schemata</span></div></a></li><li class="depth-1"><a href="plumbing.fnk.schema.html#var-unwrap-schema-form-key"><div class="inner"><span>unwrap-schema-form-key</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">plumbing.fnk.schema</h2><div class="doc"><pre class="plaintext">A very simple type system for a subset of schemas consisting of nested
maps with optional or required keyword keys; used by fnk and kin.

Since schemas are turing-complete and not really designed for type inference,
(and for simplicity) we err on the side of completeness (allowing all legal programs)
at the cost of soundness.

These operations also bake in some logic specific to reasoning about Graphs,
namely that all input keys to a node must be explicitly mentioned as optional or
required, or provided via `instance`, and will thus deliberately drop extra key
schemas on inputs as appropriate.  Output schemas may not have optional keys.</pre></div><div class="public anchor" id="var-assert-distinct"><h3>assert-distinct</h3><div class="usage"><code>(assert-distinct things)</code></div><div class="doc"><pre class="plaintext">Like (assert (distinct? things)) but with a more helpful error message.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L39">view source</a></div></div><div class="public anchor" id="var-assert-iae"><h3>assert-iae</h3><h4 class="type">macro</h4><div class="usage"><code>(assert-iae form &amp; format-args)</code></div><div class="doc"><pre class="plaintext">Like assert, but throws a RuntimeException in Clojure (not an AssertionError),
and also takes args to format.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L33">view source</a></div></div><div class="public anchor" id="var-assert-satisfies-schema"><h3>assert-satisfies-schema</h3><div class="usage"><code>(assert-satisfies-schema input-schema output-schema)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L194">view source</a></div></div><div class="public anchor" id="var-compose-schemata"><h3>compose-schemata</h3><div class="usage"><code>(compose-schemata [i2 o2] [i1 o1])</code></div><div class="doc"><pre class="plaintext">Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]

Given pairs of input and output schemata for fnks f1 and f2,
 return a pair of input and output schemata for #(f2 (merge % (f1 %))).
 f1&apos;s output schema must not contain any optional keys.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L198">view source</a></div></div><div class="public anchor" id="var-explicit-schema-key-map"><h3>explicit-schema-key-map</h3><div class="usage"><code>(explicit-schema-key-map s)</code></div><div class="doc"><pre class="plaintext">Inputs: [s]
Returns: {s/Keyword s/Bool}

Given a possibly-unevaluated map schema, return a map from bare keyword to true
 (for required) or false (for optional)</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L93">view source</a></div></div><div class="public anchor" id="var-GraphInputSchema"><h3>GraphInputSchema</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L27">view source</a></div></div><div class="public anchor" id="var-GraphIOSchemata"><h3>GraphIOSchemata</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L29">view source</a></div></div><div class="public anchor" id="var-guess-expr-output-schema"><h3>guess-expr-output-schema</h3><div class="usage"><code>(guess-expr-output-schema expr)</code></div><div class="doc"><pre class="plaintext">Guess an output schema for an expr.  Currently just looks for literal map structure and
all keyword keys.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L155">view source</a></div></div><div class="public anchor" id="var-InputSchema"><h3>InputSchema</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L23">view source</a></div></div><div class="public anchor" id="var-IOSchemata"><h3>IOSchemata</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L25">view source</a></div></div><div class="public anchor" id="var-map-schema.3F"><h3>map-schema?</h3><div class="usage"><code>(map-schema? m)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L74">view source</a></div></div><div class="public anchor" id="var-MapOutputSchema"><h3>MapOutputSchema</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L28">view source</a></div></div><div class="public anchor" id="var-non-map-diff"><h3>non-map-diff</h3><div class="usage"><code>(non-map-diff s1 s2)</code></div><div class="doc"><pre class="plaintext">Return a difference of schmas s1 and s2, where one is not a map.
Punt for now, assuming s2 always satisfies s1.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L68">view source</a></div></div><div class="public anchor" id="var-non-map-union"><h3>non-map-union</h3><div class="usage"><code>(non-map-union s1 s2)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L62">view source</a></div></div><div class="public anchor" id="var-OutputSchema"><h3>OutputSchema</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L24">view source</a></div></div><div class="public anchor" id="var-possibly-contains.3F"><h3>possibly-contains?</h3><div class="usage"><code>(possibly-contains? m k)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L217">view source</a></div></div><div class="public anchor" id="var-required-toplevel-keys"><h3>required-toplevel-keys</h3><div class="usage"><code>(required-toplevel-keys input-schema)</code></div><div class="doc"><pre class="plaintext">Inputs: [input-schema :- InputSchema]
Returns: [s/Keyword]

Which top-level keys are required (i.e., non-false) by this input schema.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L141">view source</a></div></div><div class="public anchor" id="var-safe-get"><h3>safe-get</h3><div class="usage"><code>(safe-get m k key-path)</code></div><div class="doc"><pre class="plaintext">Like (get m k), but throws if k is not present in m.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L48">view source</a></div></div><div class="public anchor" id="var-Schema"><h3>Schema</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L22">view source</a></div></div><div class="public anchor" id="var-schema-diff"><h3>schema-diff</h3><div class="usage"><code>(schema-diff input-schema output-schema)</code></div><div class="doc"><pre class="plaintext">Subtract output-schema from input-schema, returning nil if it&apos;s possible that an object
satisfying the output-schema satisfies the input-schema, or otherwise a description
of the part(s) of input-schema not met by output-schema.  Strict about the map structure
of output-schema matching input-schema, but loose about everything else (only looks at
required keys of output-schema.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L166">view source</a></div></div><div class="public anchor" id="var-schema-key"><h3>schema-key</h3><div class="usage"><code>(schema-key m k)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L208">view source</a></div></div><div class="public anchor" id="var-sequence-schemata"><h3>sequence-schemata</h3><div class="usage"><code>(sequence-schemata [i1 o1] [k [i2 o2]])</code></div><div class="doc"><pre class="plaintext">Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword &quot;key&quot;) (s/one IOSchemata &quot;inner-schemas&quot;)]]
Returns: GraphIOSchemata

Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,
 return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L230">view source</a></div></div><div class="public anchor" id="var-split-schema"><h3>split-schema</h3><div class="usage"><code>(split-schema s ks)</code></div><div class="doc"><pre class="plaintext">Inputs: [s :- InputSchema ks :- [s/Keyword]]

Return a pair [ks-part non-ks-part], with any extra schema removed.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L220">view source</a></div></div><div class="public anchor" id="var-split-schema-keys"><h3>split-schema-keys</h3><div class="usage"><code>(split-schema-keys s)</code></div><div class="doc"><pre class="plaintext">Inputs: [s :- {s/Keyword s/Bool}]
Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]

Given output of explicit-schema-key-map, split into seq [req opt].</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L102">view source</a></div></div><div class="public anchor" id="var-union-input-schemata"><h3>union-input-schemata</h3><div class="usage"><code>(union-input-schemata i1 i2)</code></div><div class="doc"><pre class="plaintext">Inputs: [i1 :- InputSchema i2 :- InputSchema]
Returns: InputSchema

Returns a minimal input schema schema that entails satisfaction of both s1 and s2</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L124">view source</a></div></div><div class="public anchor" id="var-unwrap-schema-form-key"><h3>unwrap-schema-form-key</h3><div class="usage"><code>(unwrap-schema-form-key k)</code></div><div class="doc"><pre class="plaintext">Inputs: [k]
Returns: (s/maybe (s/pair s/Keyword &quot;k&quot; s/Bool &quot;optional?&quot;))

Given a possibly-unevaluated schema map key form, unpack an explicit keyword
 and optional? flag, or return nil for a non-explicit key</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/fnk/schema.cljx#L81">view source</a></div></div></div></body></html>