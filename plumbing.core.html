<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>plumbing.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Plumbing 0.4.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plumbing</span></div></div></li><li class="depth-2 branch current"><a href="plumbing.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fnk</span></div></div></li><li class="depth-3 branch"><a href="plumbing.fnk.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-3 branch"><a href="plumbing.fnk.pfnk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfnk</span></div></a></li><li class="depth-3"><a href="plumbing.fnk.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch"><a href="plumbing.graph.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2"><a href="plumbing.graph-async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph-async</span></div></a></li><li class="depth-3"><a href="plumbing.graph.positional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>positional</span></div></a></li><li class="depth-2"><a href="plumbing.map.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>map</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="plumbing.core.html#var--unless-update"><div class="inner"><span>-unless-update</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-.3C-"><div class="inner"><span>&lt;-</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-.3F.3E"><div class="inner"><span>?&gt;</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-.3F.3E.3E"><div class="inner"><span>?&gt;&gt;</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-aconcat"><div class="inner"><span>aconcat</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-as-.3E.3E"><div class="inner"><span>as-&gt;&gt;</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-assoc-when"><div class="inner"><span>assoc-when</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-conj-when"><div class="inner"><span>conj-when</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-cons-when"><div class="inner"><span>cons-when</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-count-when"><div class="inner"><span>count-when</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-defnk"><div class="inner"><span>defnk</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-dissoc-in"><div class="inner"><span>dissoc-in</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-distinct-by"><div class="inner"><span>distinct-by</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-distinct-fast"><div class="inner"><span>distinct-fast</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-distinct-id"><div class="inner"><span>distinct-id</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-fn-.3E"><div class="inner"><span>fn-&gt;</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-fn-.3E.3E"><div class="inner"><span>fn-&gt;&gt;</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-fnk"><div class="inner"><span>fnk</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-for-map"><div class="inner"><span>for-map</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-frequencies-fast"><div class="inner"><span>frequencies-fast</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-get-and-set.21"><div class="inner"><span>get-and-set!</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-grouped-map"><div class="inner"><span>grouped-map</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-if-letk"><div class="inner"><span>if-letk</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-indexed"><div class="inner"><span>indexed</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-interleave-all"><div class="inner"><span>interleave-all</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-keywordize-map"><div class="inner"><span>keywordize-map</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-lazy-get"><div class="inner"><span>lazy-get</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-letk"><div class="inner"><span>letk</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-map-from-keys"><div class="inner"><span>map-from-keys</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-map-from-vals"><div class="inner"><span>map-from-vals</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-map-keys"><div class="inner"><span>map-keys</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-map-vals"><div class="inner"><span>map-vals</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-mapply"><div class="inner"><span>mapply</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-memoized-fn"><div class="inner"><span>memoized-fn</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-millis"><div class="inner"><span>millis</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-positions"><div class="inner"><span>positions</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-rsort-by"><div class="inner"><span>rsort-by</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-safe-get"><div class="inner"><span>safe-get</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-safe-get-in"><div class="inner"><span>safe-get-in</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-singleton"><div class="inner"><span>singleton</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-sum"><div class="inner"><span>sum</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-swap-pair.21"><div class="inner"><span>swap-pair!</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-unchunk"><div class="inner"><span>unchunk</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-update"><div class="inner"><span>update</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-update-in-when"><div class="inner"><span>update-in-when</span></div></a></li><li class="depth-1"><a href="plumbing.core.html#var-when-letk"><div class="inner"><span>when-letk</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">plumbing.core</h2><div class="doc"><pre class="plaintext">Utility belt for Clojure in the wild
</pre></div><div class="public anchor" id="var--unless-update"><h3>-unless-update</h3><h4 class="type">macro</h4><div class="usage"><code>(-unless-update body)</code></div><div class="doc"><pre class="plaintext">Execute and yield body only if Clojure version preceeds introduction
of &apos;update&apos; into core namespace.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L41">view source</a></div></div><div class="public anchor" id="var-.3C-"><h3>&lt;-</h3><h4 class="type">macro</h4><div class="usage"><code>(&lt;- &amp; body)</code></div><div class="doc"><pre class="plaintext">Converts a -&gt;&gt; to a -&gt;

(-&gt;&gt; (range 10) (map inc) (&lt;- (doto prn)) (reduce +))

Jason W01fe is happy to give a talk anywhere any time on
the calculus of arrow macros</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L328">view source</a></div></div><div class="public anchor" id="var-.3F.3E"><h3>?&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(?&gt; arg do-it? &amp; rest)</code></div><div class="doc"><pre class="plaintext">Conditional single-arrow operation (-&gt; m (?&gt; add-kv? (assoc :k :v)))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L311">view source</a></div></div><div class="public anchor" id="var-.3F.3E.3E"><h3>?&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(?&gt;&gt; do-it? &amp; args)</code></div><div class="doc"><pre class="plaintext">Conditional double-arrow operation (-&gt;&gt; nums (?&gt;&gt; inc-all? (map inc)))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L304">view source</a></div></div><div class="public anchor" id="var-aconcat"><h3>aconcat</h3><div class="usage"><code>(aconcat s)</code></div><div class="doc"><pre class="plaintext">Like (apply concat s) but lazier (and shorter) 
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L173">view source</a></div></div><div class="public anchor" id="var-as-.3E.3E"><h3>as-&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(as-&gt;&gt; name &amp; forms-and-expr)</code></div><div class="doc"><pre class="plaintext">Like as-&gt;, but can be used in double arrow.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L338">view source</a></div></div><div class="public anchor" id="var-assoc-when"><h3>assoc-when</h3><div class="usage"><code>(assoc-when m &amp; kvs)</code></div><div class="doc"><pre class="plaintext">Like assoc but only assocs when value is truthy
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L141">view source</a></div></div><div class="public anchor" id="var-conj-when"><h3>conj-when</h3><div class="usage"><code>(conj-when coll x)</code><code>(conj-when coll x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Like conj but ignores non-truthy values
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L282">view source</a></div></div><div class="public anchor" id="var-cons-when"><h3>cons-when</h3><div class="usage"><code>(cons-when x s)</code></div><div class="doc"><pre class="plaintext">Like cons but does nothing if x is non-truthy.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L292">view source</a></div></div><div class="public anchor" id="var-count-when"><h3>count-when</h3><div class="usage"><code>(count-when pred xs)</code></div><div class="doc"><pre class="plaintext">Returns # of elements of xs where pred holds
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L277">view source</a></div></div><div class="public anchor" id="var-defnk"><h3>defnk</h3><h4 class="type">macro</h4><div class="usage"><code>(defnk &amp; defnk-args)</code></div><div class="doc"><pre class="plaintext">Analogy: fn:fnk :: defn::defnk
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L473">view source</a></div></div><div class="public anchor" id="var-dissoc-in"><h3>dissoc-in</h3><div class="usage"><code>(dissoc-in m [k &amp; ks])</code></div><div class="doc"><pre class="plaintext">Dissociate this keyseq from m, removing any empty maps created as a result
(including at the top-level).</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L94">view source</a></div></div><div class="public anchor" id="var-distinct-by"><h3>distinct-by</h3><div class="usage"><code>(distinct-by f xs)</code></div><div class="doc"><pre class="plaintext">Returns elements of xs which return unique
values according to f. If multiple elements of xs return the same
value under f, the first is returned</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L237">view source</a></div></div><div class="public anchor" id="var-distinct-fast"><h3>distinct-fast</h3><div class="usage"><code>(distinct-fast xs)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/distinct, but faster.
Uses Java&apos;s equal/hash, so may produce incorrect results if
given values that are = but not .equal</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L229">view source</a></div></div><div class="public anchor" id="var-distinct-id"><h3>distinct-id</h3><div class="usage"><code>(distinct-id xs)</code></div><div class="doc"><pre class="plaintext">Like distinct but uses reference rather than value identity, very clojurey
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L259">view source</a></div></div><div class="public anchor" id="var-fn-.3E"><h3>fn-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(fn-&gt; &amp; body)</code></div><div class="doc"><pre class="plaintext">Equivalent to `(fn [x] (-&gt; x ~@body))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L318">view source</a></div></div><div class="public anchor" id="var-fn-.3E.3E"><h3>fn-&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(fn-&gt;&gt; &amp; body)</code></div><div class="doc"><pre class="plaintext">Equivalent to `(fn [x] (-&gt;&gt; x ~@body))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L323">view source</a></div></div><div class="public anchor" id="var-fnk"><h3>fnk</h3><h4 class="type">macro</h4><div class="usage"><code>(fnk &amp; args)</code></div><div class="doc"><pre class="plaintext">Keyword fn, using letk.  Generates a prismatic/schema schematized fn that
accepts a single explicit map i.e., (f {:foo :bar}).

Explicit top-level map structure will be recorded in output spec, or
to capture implicit structure use an explicit prismatic/schema hint on the
function name.

Individual inputs can also be schematized by putting :- schemas after the
binding symbol.  Schemas can also be used on &amp; more symbols to describe
additional map inputs, or on entire [] bindings to override the automatically
generated schema for the contents (caveat emptor).

By default, input schemas allow for arbitrary additional mappings
({s/Keyword s/Any}) unless explicit binding or &amp; more schemas are provided.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L451">view source</a></div></div><div class="public anchor" id="var-for-map"><h3>for-map</h3><h4 class="type">macro</h4><div class="usage"><code>(for-map seq-exprs key-expr val-expr)</code><code>(for-map m-sym seq-exprs key-expr val-expr)</code></div><div class="doc"><pre class="plaintext">Like &apos;for&apos; for building maps. Same bindings except the body should have a
key-expression and value-expression. If a key is repeated, the last
value (according to &quot;for&quot; semantics) will be retained.

(= (for-map [i (range 2) j (range 2)] [i j] (even? (+ i j)))
   {[0 0] true, [0 1] false, [1 0] false, [1 1] true})

An optional symbol can be passed as a first argument, which will be
bound to the transient map containing the entries produced so far.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L22">view source</a></div></div><div class="public anchor" id="var-frequencies-fast"><h3>frequencies-fast</h3><div class="usage"><code>(frequencies-fast xs)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/frequencies, but faster.
Uses Java&apos;s equal/hash, so may produce incorrect results if
given values that are = but not .equal</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L218">view source</a></div></div><div class="public anchor" id="var-get-and-set.21"><h3>get-and-set!</h3><div class="usage"><code>(get-and-set! a new-val)</code></div><div class="doc"><pre class="plaintext">Like reset! but returns old-val
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L375">view source</a></div></div><div class="public anchor" id="var-grouped-map"><h3>grouped-map</h3><div class="usage"><code>(grouped-map key-fn map-fn coll)</code></div><div class="doc"><pre class="plaintext">Like group-by, but accepts a map-fn that is applied to values before
collected.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L158">view source</a></div></div><div class="public anchor" id="var-if-letk"><h3>if-letk</h3><h4 class="type">macro</h4><div class="usage"><code>(if-letk bindings then)</code><code>(if-letk bindings then else)</code></div><div class="doc"><pre class="plaintext">bindings =&gt; binding-form test

If test is true, evaluates then with binding-form bound to the value of
test, if not, yields else</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L427">view source</a></div></div><div class="public anchor" id="var-indexed"><h3>indexed</h3><div class="usage"><code>(indexed s)</code></div><div class="doc"><pre class="plaintext">Returns [idx x] for x in seqable s
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L207">view source</a></div></div><div class="public anchor" id="var-interleave-all"><h3>interleave-all</h3><div class="usage"><code>(interleave-all &amp; colls)</code></div><div class="doc"><pre class="plaintext">Analogy: partition:partition-all :: interleave:interleave-all
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L267">view source</a></div></div><div class="public anchor" id="var-keywordize-map"><h3>keywordize-map</h3><div class="usage"><code>(keywordize-map x)</code></div><div class="doc"><pre class="plaintext">Recursively convert maps in m (including itself)
to have keyword keys instead of string</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L105">view source</a></div></div><div class="public anchor" id="var-lazy-get"><h3>lazy-get</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-get m k d)</code></div><div class="doc"><pre class="plaintext">Like get but lazy about default
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L120">view source</a></div></div><div class="public anchor" id="var-letk"><h3>letk</h3><h4 class="type">macro</h4><div class="usage"><code>(letk bindings &amp; body)</code></div><div class="doc"><pre class="plaintext">Keyword let.  Accepts an interleaved sequence of binding forms and map forms like:
(letk [[a {b 2} [:f g h] c d {e 4} :as m &amp; more] a-map ...] &amp; body)
a, c, d, and f are required keywords, and letk will barf if not in a-map.
b and e are optional, and will be bound to default values if not present.
g and h are required keys in the map found under :f.
m will be bound to the entire map (a-map).
more will be bound to all the unbound keys (ie (dissoc a-map :a :b :c :d :e)).
:as and &amp; are both optional, but must be at the end in the specified order if present.
The same symbol cannot be bound multiple times within the same destructing level.

Optional values can reference symbols bound earlier within the same binding, i.e.,
(= [2 2] (let [a 1] (letk [[a {b a}] {:a 2}] [a b]))) but
(= [2 1] (let [a 1] (letk [[{b a} a] {:a 2}] [a b])))

If present, :as and :&amp; symbols are bound before other symbols within the binding.

Namespaced keys are supported by specifying fully-qualified key in binding form. The bound
symbol uses the _name_ portion of the namespaced key, i.e,
(= 1 (letk [[a/b] {:a/b 1}] b))</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L393">view source</a></div></div><div class="public anchor" id="var-map-from-keys"><h3>map-from-keys</h3><div class="usage"><code>(map-from-keys f ks)</code></div><div class="doc"><pre class="plaintext">Build map k -&gt; (f k) for keys in ks
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L84">view source</a></div></div><div class="public anchor" id="var-map-from-vals"><h3>map-from-vals</h3><div class="usage"><code>(map-from-vals f vs)</code></div><div class="doc"><pre class="plaintext">Build map (f v) -&gt; v for vals in vs
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L89">view source</a></div></div><div class="public anchor" id="var-map-keys"><h3>map-keys</h3><div class="usage"><code>(map-keys f m)</code></div><div class="doc"><pre class="plaintext">Build map (f k) -&gt; v for [k v] in map m
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L77">view source</a></div></div><div class="public anchor" id="var-map-vals"><h3>map-vals</h3><div class="usage"><code>(map-vals f m)</code></div><div class="doc"><pre class="plaintext">Build map k -&gt; (f v) for [k v] in map, preserving the initial type
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L66">view source</a></div></div><div class="public anchor" id="var-mapply"><h3>mapply</h3><div class="usage"><code>(mapply f m)</code><code>(mapply f arg &amp; args)</code></div><div class="doc"><pre class="plaintext">Like apply, but applies a map to a function with positional map
arguments. Can take optional initial args just like apply.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L384">view source</a></div></div><div class="public anchor" id="var-memoized-fn"><h3>memoized-fn</h3><h4 class="type">macro</h4><div class="usage"><code>(memoized-fn name args &amp; body)</code></div><div class="doc"><pre class="plaintext">Like fn, but memoized (including recursive calls).

The clojure.core memoize correctly caches recursive calls when you do a top-level def
of your memoized function, but if you want an anonymous fibonacci function, you must use
memoized-fn rather than memoize to cache the recursive calls.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L343">view source</a></div></div><div class="public anchor" id="var-millis"><h3>millis</h3><div class="usage"><code>(millis)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L380">view source</a></div></div><div class="public anchor" id="var-positions"><h3>positions</h3><div class="usage"><code>(positions f s)</code></div><div class="doc"><pre class="plaintext">Returns indices idx of sequence s where (f (nth s idx))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L212">view source</a></div></div><div class="public anchor" id="var-rsort-by"><h3>rsort-by</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Like sort-by, but prefers higher values rather than lower ones.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L297">view source</a></div></div><div class="public anchor" id="var-safe-get"><h3>safe-get</h3><div class="usage"><code>(safe-get m k)</code></div><div class="doc"><pre class="plaintext">Like get but throw an exception if not found
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L127">view source</a></div></div><div class="public anchor" id="var-safe-get-in"><h3>safe-get-in</h3><div class="usage"><code>(safe-get-in m ks)</code></div><div class="doc"><pre class="plaintext">Like get-in but throws exception if not found
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L134">view source</a></div></div><div class="public anchor" id="var-singleton"><h3>singleton</h3><div class="usage"><code>(singleton xs)</code></div><div class="doc"><pre class="plaintext">returns (first xs) when xs has only 1 element
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L200">view source</a></div></div><div class="public anchor" id="var-sum"><h3>sum</h3><div class="usage"><code>(sum f xs)</code><code>(sum xs)</code></div><div class="doc"><pre class="plaintext">Return sum of (f x) for each x in xs
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L195">view source</a></div></div><div class="public anchor" id="var-swap-pair.21"><h3>swap-pair!</h3><div class="usage"><code>(swap-pair! a f)</code><code>(swap-pair! a f &amp; args)</code></div><div class="doc"><pre class="plaintext">Like swap! but returns a pair [old-val new-val]
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L363">view source</a></div></div><div class="public anchor" id="var-unchunk"><h3>unchunk</h3><div class="usage"><code>(unchunk s)</code></div><div class="doc"><pre class="plaintext">Takes a seqable and returns a lazy sequence that
 is maximally lazy and doesn&apos;t realize elements due to either
 chunking or apply.

 Useful when you don&apos;t want chunking, for instance,
 (first awesome-website? (map slurp +a-bunch-of-urls+))
 may slurp up to 31 unneed webpages, wherease
 (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))
 is guaranteed to stop slurping after the first awesome website.

Taken from <a href="http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci">http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci</a></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L178">view source</a></div></div><div class="public anchor" id="var-update"><h3>update</h3><div class="usage"><code>(update m k f)</code><code>(update m k f x1)</code><code>(update m k f x1 x2)</code><code>(update m k f x1 x2 &amp; xs)</code></div><div class="doc"><pre class="plaintext">Updates the value in map m at k with the function f.

Like update-in, but for updating a single top-level key.
Any additional args will be passed to f after the value.

WARNING As of Clojure 1.7 this function exists in clojure.core and
will not be exported by this namespace.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L53">view source</a></div></div><div class="public anchor" id="var-update-in-when"><h3>update-in-when</h3><div class="usage"><code>(update-in-when m key-seq f &amp; args)</code></div><div class="doc"><pre class="plaintext">Like update-in but returns m unchanged if key-seq is not present.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L150">view source</a></div></div><div class="public anchor" id="var-when-letk"><h3>when-letk</h3><h4 class="type">macro</h4><div class="usage"><code>(when-letk bindings &amp; body)</code></div><div class="doc"><pre class="plaintext">bindings =&gt; binding-form test

When test is true, evaluates body with binding-form bound to the value of test</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/core.cljx#L444">view source</a></div></div></div></body></html>