<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>plumbing.graph documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Plumbing 0.3.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plumbing</span></div></div></li><li class="depth-2 branch"><a href="plumbing.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fnk</span></div></div></li><li class="depth-3 branch"><a href="plumbing.fnk.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-3 branch"><a href="plumbing.fnk.pfnk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfnk</span></div></a></li><li class="depth-3"><a href="plumbing.fnk.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch current"><a href="plumbing.graph.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2"><a href="plumbing.graph-async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph-async</span></div></a></li><li class="depth-3"><a href="plumbing.graph.positional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>positional</span></div></a></li><li class="depth-2"><a href="plumbing.map.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>map</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="plumbing.graph.html#var--.3Egraph"><div class="inner"><span>-&gt;graph</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-check-comp-partial.21"><div class="inner"><span>check-comp-partial!</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-comp-partial"><div class="inner"><span>comp-partial</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-comp-partial-fn"><div class="inner"><span>comp-partial-fn</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-compile"><div class="inner"><span>compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-eager-compile"><div class="inner"><span>eager-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-graph"><div class="inner"><span>graph</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-instance"><div class="inner"><span>instance</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-interpreted-eager-compile"><div class="inner"><span>interpreted-eager-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-io-schemata*"><div class="inner"><span>io-schemata*</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-lazy-compile"><div class="inner"><span>lazy-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-par-compile"><div class="inner"><span>par-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-positional-eager-compile"><div class="inner"><span>positional-eager-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-profiled"><div class="inner"><span>profiled</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-restricted-call"><div class="inner"><span>restricted-call</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-run"><div class="inner"><span>run</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-simple-flat-compile"><div class="inner"><span>simple-flat-compile</span></div></a></li><li class="depth-1"><a href="plumbing.graph.html#var-simple-hierarchical-compile"><div class="inner"><span>simple-hierarchical-compile</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">plumbing.graph</h2><div class="doc"><pre class="plaintext">A Graph is a simple, declarative way to define a composition of functions that is
easy to define, modify, execute, test, and monitor.

This blog post provides a high-level overview of Graph and its benefits:
<a href="http://blog.getprismatic.com/blog/2012/10/1/prismatics-graph-at-strange-loop.html">http://blog.getprismatic.com/blog/2012/10/1/prismatics-graph-at-strange-loop.html</a>

Concretely, a Graph specification is just a Clojure (nested) map with keyword keys
and keyword functions at the leaves.

A Graph is defined recursively as either:
  1. a keyword function (i.e., fn satisfying PFnk), or
  2. a Clojure map from keywords to (sub)graphs.

A Graph is a declarative specification of a single keyword function that
produces a map output, where each value in the output is produced by executing
the corresponding keyword function in the Graph.  The inputs to the keyword
function are given by the outputs of other nodes in the graph with matching
keywords (mimicking lexical scope in the case of nested maps), or failing that,
from keywords in the input map.

For more details and examples of Graphs, see test/plumbing/graph_examples_test.cljx.</pre></div><div class="public anchor" id="var--.3Egraph"><h3>-&gt;graph</h3><div class="usage"><code>(-&gt;graph graph-nodes)</code></div><div class="doc"><pre class="plaintext">Convert a graph specification into a canonical well-formed &apos;graph&apos;, which
is an array-map with nodes in a correct topological order that will respond
to &apos;io-schemata&apos; with a specification of the graph inputs and outputs.

The graph specification can be a Clojure map, in which case the topological
order will be computed (an error will be thrown for cyclic specifications),
or a sequence of key-value pairs that are already in a valid topological order
(an error will be thrown if the order is not valid).  Values in the input
sequence are also converted to canonical graphs via recursive calls to -&gt;graph.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L38">view source</a></div></div><div class="public anchor" id="var-check-comp-partial.21"><h3>check-comp-partial!</h3><div class="usage"><code>(check-comp-partial! g instance-fn)</code></div><div class="doc"><pre class="plaintext">Check that instance-fn is a valid fn to comp-partial with graph g.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L239">view source</a></div></div><div class="public anchor" id="var-comp-partial"><h3>comp-partial</h3><div class="usage"><code>(comp-partial g instance-fn)</code></div><div class="doc"><pre class="plaintext">Experimental.

An extension of pfnk/comp-partial that supplies new parameters to a subgraph,
useful in composing hierarchical graphs.

g is a graph, and instance-fn is a fnk that takes arguments from the surrounding
context and produces new parameters that are fed into g.  Works by comp-partialing
all leafs that expects any parameter produced by instance-fn with instance-fn,
so beware of expensive instance-fns, or those that expect caching of some sort
(i.e., attempt to generate shared state).

Throws an error if any parameter supplied by instance-fn is not used by at least
one node in g.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L257">view source</a></div></div><div class="public anchor" id="var-comp-partial-fn"><h3>comp-partial-fn</h3><div class="usage"><code>(comp-partial-fn f other)</code></div><div class="doc"><pre class="plaintext">Return a new pfnk representing the composition #(f (merge % (other %)))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L250">view source</a></div></div><div class="public anchor" id="var-compile"><h3>compile</h3><div class="usage"><code>(compile g)</code></div><div class="doc"><pre class="plaintext">Compile graph specification g to a corresponding fnk using the a default
compile strategy for host.
Clojure: eager-compile
ClojureScript: interpreted-eager-compile</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L221">view source</a></div></div><div class="public anchor" id="var-eager-compile"><h3>eager-compile</h3><div class="usage"><code>(eager-compile g)</code></div><div class="doc"><pre class="plaintext">Compile graph specification g to a corresponding fnk that is optimized for
speed. Wherever possible, fnks are called positionally, to reduce the
overhead of creating and destructuring maps, and the return value is a
record, which is much faster to create and access than a map.  Compilation
is relatively slow, however, due to internal calls to &apos;eval&apos;.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L111">view source</a></div></div><div class="public anchor" id="var-graph"><h3>graph</h3><div class="usage"><code>(graph &amp; nodes)</code></div><div class="doc"><pre class="plaintext">An ordered constructor for graphs, which enforces that the Graph is provided
in a valid topological ordering.  This is a sanity check, and also enforces
defining graphs in a readable way.  Most explicit graphs should be created
with this constructor.

(graph
  :x-plus-1   (fnk [x] (inc x))
  :2-x-plus-2 (fnk [x-plus-1] (* 2 x-plus-1)))

in addition, an &apos;inline&apos; graph can be provided in place of a key-value
sequence, which will be merged into the graph at this position.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L89">view source</a></div></div><div class="public anchor" id="var-instance"><h3>instance</h3><h4 class="type">macro</h4><div class="usage"><code>(instance g m)</code><code>(instance g bind m)</code></div><div class="doc"><pre class="plaintext">Experimental.

Convenience macro for comp-partial, used to supply inline parameters to a
subgraph (or fnk).

Example:
(= {:x 21}
   (run (instance {:x (fnk [a] (inc a))} [z] {:a (* z 2)})
        {:z 10}))</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L284">view source</a></div></div><div class="public anchor" id="var-interpreted-eager-compile"><h3>interpreted-eager-compile</h3><div class="usage"><code>(interpreted-eager-compile g)</code></div><div class="doc"><pre class="plaintext">Compile graph specification g to a corresponding fnk that returns an
ordinary Clojure map of the node result fns on a given input.  The
compilation is must faster than &apos;eager-compile&apos;, but the compiled fn
will typically be much slower.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L175">view source</a></div></div><div class="public anchor" id="var-io-schemata*"><h3>io-schemata*</h3><div class="usage"><code>(io-schemata* g)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L71">view source</a></div></div><div class="public anchor" id="var-lazy-compile"><h3>lazy-compile</h3><div class="usage"><code>(lazy-compile g)</code></div><div class="doc"><pre class="plaintext">Compile graph specification g to a corresponding fnk that returns a
lazymap of the node result fns on a given input.  This fnk returns
the lazymap immediately, and node values are computed and cached as needed
as values are extracted from the lazymap.  Besides this lazy behavior,
the lazymap can be used interchangeably with an ordinary Clojure map.
Required inputs to the graph are checked lazily, so you can omit input
keys not required by unneeded output keys.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L188">view source</a></div></div><div class="public anchor" id="var-par-compile"><h3>par-compile</h3><div class="usage"><code>(par-compile g)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L204">view source</a></div></div><div class="public anchor" id="var-positional-eager-compile"><h3>positional-eager-compile</h3><div class="usage"><code>(positional-eager-compile g arg-ks)</code></div><div class="doc"><pre class="plaintext">Like eager-compile, but produce a non-keyword function that can be called
with args in the order provided by arg-ks, avoiding the overhead of creating
and destructuring a top-level map.  This can yield a substantially faster
fn for Graphs with very computationally inexpensive node fnks.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L125">view source</a></div></div><div class="public anchor" id="var-profiled"><h3>profiled</h3><div class="usage"><code>(profiled profile-key g)</code></div><div class="doc"><pre class="plaintext">Modify graph spec g, producing a new graph spec with a new top-level key
&apos;profile-key&apos;.  After each node value is computed, the number of milliseconds
taken to compute its value will be stored under an atom at &apos;profile-key&apos;.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L298">view source</a></div></div><div class="public anchor" id="var-restricted-call"><h3>restricted-call</h3><div class="usage"><code>(restricted-call f in-m)</code></div><div class="doc"><pre class="plaintext">Call fnk f on the subset of keys its input schema explicitly asks for
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L170">view source</a></div></div><div class="public anchor" id="var-run"><h3>run</h3><div class="usage"><code>(run g input)</code></div><div class="doc"><pre class="plaintext">Eagerly run a graph on an input by compiling and then executing on this input.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L230">view source</a></div></div><div class="public anchor" id="var-simple-flat-compile"><h3>simple-flat-compile</h3><div class="usage"><code>(simple-flat-compile g check-input? make-map assoc-f)</code></div><div class="doc"><pre class="plaintext">Helper method for simple (non-nested) graph compilations that convert a graph
specification to a fnk that returns a Clojure map of the graph node values.
(make-map m) converts an initial Clojure map m to the return type of the fnk,
and (assoc-f m k f) associates the value given by (f) under key k to map m.</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L133">view source</a></div></div><div class="public anchor" id="var-simple-hierarchical-compile"><h3>simple-hierarchical-compile</h3><div class="usage"><code>(simple-hierarchical-compile g check-input? make-map assoc-f)</code></div><div class="doc"><pre class="plaintext">Hierarchical extension of simple-nonhierarchical-compile.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/plumbing/blob/master/src/plumbing/graph.cljx#L160">view source</a></div></div></div></body></html>